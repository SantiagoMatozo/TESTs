<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simulador de Sifón — Alturas Ajustables</title>
  <style>
    :root{--bg:#fff;--card:#ffff;--accent:#006b59;--muted:#ffff}
    html,body{
      height:100%;
      margin:0;
      font-family:Inter,Segoe UI,Roboto,Arial;
      color:#006b59;
      background:linear-gradient(180deg,#ffe9d7 0%, #fde2cb 100%)
    }
    .app{
      display:grid;
      grid-template-columns:420px 1fr;
      gap:18px;
      padding:18px;
      max-height:95vh
    }
    .panel{
      background:linear-gradient(180deg,#ffe0c5,#fff8f8);
      border-radius:12px;
      padding-left:18px;
      padding-right:18px;
      padding-top:18px;
      box-shadow:0 6px 18px #003a30;
    }
    h1{margin:0 0 10px;font-size:20px}
    label{
      display:block;margin-top:12px;
      color:#006b59;font-size:15px;font-weight:600;
    }
    .control{display:flex;gap:10px;align-items:center;}
    input[type=range]{width:100%}
    .row{display:flex;gap:8px;margin-top:12px}
    button{
      background:var(--accent);
      border:0;
      padding:8px 12px;
      border-radius:8px;
      color:#fff;
      cursor:pointer;
      font-weight:600
    }
    button.secondary{
      background-color:#006b59;
      color:#fff;
      border:1px solid rgba(255,255,255,0.06);
    }
    .meta{
      font-size:15px;
      color:#003a30;
      margin-top:8px;
      font-weight:600;
    }
    .footer{
      font-size:12px;
      color:#003a30;
      margin-top:10px;
      font-weight:600;
    }
    canvas{
      width:100%;
      height:100%;
      display:block;
      border-radius:12px;
      background:linear-gradient(180deg,#ffe0c5,#fff8f8);
    }

    /* checkbox inline */
    .checkbox-row{display:flex;gap:8px;align-items:center;margin-top:12px}
    .small-muted{font-size:12px;color:#003a30;font-weight:500;margin-top:6px}
    .warning{color:#a60000;font-weight:800}
  </style>
</head>
<body>
  <div class="app">
    <div class="panel" style="min-height:640px;">
      <h1>Simulador de sifón — vasos ajustables</h1>
      <div class="meta">Ajustá las alturas de los dos vasos (izq y der). Usa <strong>Primar</strong> para iniciar el sifón y ver el flujo.</div>

      <label>Altura del banco (offset físico del vaso izq, cm): <span id="leftOffsetTxt">0</span></label>
      <div class="control"><input id="leftOffset" type="range" min="0" max="60" value="0" step="1"></div>

      <label>Altura vaso izquierdo (cm): <span id="leftHtxt">40</span></label>
      <div class="control"><input id="leftH" type="range" min="0" max="100" value="40" step="1"></div>

      <label>Altura vaso derecho (cm): <span id="rightHtxt">10</span></label>
      <div class="control"><input id="rightH" type="range" min="0" max="100" value="10" step="1"></div>

      <label>Altura de la cresta del sifón (cm): <span id="crestTxt">60</span></label>
      <div class="control"><input id="crestH" type="range" min="0" max="120" value="60" step="1"></div>

      <label>Diámetro del tubo (cm): <span id="diamTxt">1.5</span></label>
      <div class="control"><input id="diam" type="range" min="0.5" max="5" value="1.5" step="0.1"></div>

      <div class="checkbox-row">
        <input id="hoseFilled" type="checkbox">
        <label for="hoseFilled" style="margin:0;font-weight:600;color:#006b59">Iniciar con la manguera llena (cebada)</label>
      </div>
      <div class="small-muted">Si activás esto, el sifón queda cebado al iniciar y puede fluir si las alturas lo permiten.</div>

      <div class="row">
        <button id="primeBtn">Iniciar Simulación</button>
        <button id="pauseBtn" class="secondary">Pausa</button>
        <button id="resetBtn" class="secondary">Resetear</button>
      </div>

      <div class="meta">
        <strong>Estado:</strong> <span id="status">Inactivo</span>
      </div>

      <div class="footer">Modelo ideal con detección de cavitación. Caudal Q = A·v where v = sqrt(2gΔh).</div>
    </div>

    <div class="panel" style="padding:0;min-height:640px;">
      <canvas id="simCanvas" width="900" height="640"></canvas>
    </div>
  </div>

<script>
/* -------------------------
   Setup y referencias DOM
   ------------------------- */
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

const g_SI = 9.80665; // m/s^2
const rho = 1000;    // kg/m^3 (agua)
const P_ATM = 101325; // Pa
const P_VAPOR_20C = 2339; // Pa aprox a 20°C

let C = 0.6; // coef arrastre ilustrativo

const leftOffsetEl = document.getElementById('leftOffset');
const leftOffsetTxt = document.getElementById('leftOffsetTxt');
const leftH = document.getElementById('leftH');
const rightH = document.getElementById('rightH');
const crestH = document.getElementById('crestH');
const diam = document.getElementById('diam');
const leftHtxt = document.getElementById('leftHtxt');
const rightHtxt = document.getElementById('rightHtxt');
const crestTxt = document.getElementById('crestTxt');
const diamTxt = document.getElementById('diamTxt');
const hoseFilledEl = document.getElementById('hoseFilled');

const primeBtn = document.getElementById('primeBtn');
const pauseBtn = document.getElementById('pauseBtn');
const resetBtn = document.getElementById('resetBtn');
const statusEl = document.getElementById('status');

/* -------------------------
   Layout / escala gráfica
   ------------------------- */
const tankWidth = 160;
const tankXLeft = 90;
const tankXRight = W - 90 - tankWidth;
const tankBottom = H - 70;
const tankHeightPx = 300;      // alto en píxeles del tanque (FIJO)
const maxPhysicalHeight = 120; // cm (valor máximo representado verticalmente)

// convierte cm físicos a px
function physToPx(hCm){ return (hCm / maxPhysicalHeight) * tankHeightPx; }

// top (y) del tanque aplicando offset (offset en cm)
// offset positivo -> desplaza el tanque hacia arriba (y menor)
function tankTopY(offsetCm){
  return (tankBottom - tankHeightPx) - physToPx(offsetCm);
}

// devuelve la Y (en px) del tope del agua dentro del tanque (considerando que
// levelCm es la altura absoluta de la superficie libre sobre la referencia).
// offsetCm desplaza el tanque en Y pero el nivel se mapea dentro del tanque.
function waterYInTank(levelCm, offsetCm){
  const topTank = tankTopY(offsetCm);
  // convertimos la altura física de la columna (levelCm) en altura en px dentro del tanque:
  const waterHeightPx = Math.min(physToPx(levelCm), tankHeightPx); // clamp para no salir del tanque
  // el agua se dibuja desde (topTank + (tankHeightPx - waterHeightPx)) hacia abajo
  return topTank + (tankHeightPx - waterHeightPx);
}

/* -------------------------
   Estado
   ------------------------- */
let state = {
  leftLevel: parseFloat(leftH.value),   // cm (altura absoluta)
  rightLevel: parseFloat(rightH.value), // cm
  crestLevel: parseFloat(crestH.value), // cm
  diameter: parseFloat(diam.value),     // cm
  leftOffset: parseFloat(leftOffsetEl.value), // cm (desplazamiento del tanque izq)
  primed: false,
  flowing: false,
  paused: false,
  hoseFilled: hoseFilledEl.checked
};

/* -------------------------
   Listeners
   ------------------------- */
[leftOffsetEl, leftH, rightH, crestH, diam, hoseFilledEl].forEach(el => el.addEventListener('input', ()=>{
  state.leftOffset = parseFloat(leftOffsetEl.value);
  state.leftLevel = parseFloat(leftH.value);
  state.rightLevel = parseFloat(rightH.value);
  state.crestLevel = parseFloat(crestH.value);
  state.diameter = parseFloat(diam.value);
  state.hoseFilled = hoseFilledEl.checked;

  leftOffsetTxt.textContent = state.leftOffset;
  leftHtxt.textContent = state.leftLevel;
  rightHtxt.textContent = state.rightLevel;
  crestTxt.textContent = state.crestLevel;
  diamTxt.textContent = state.diameter;
}));

primeBtn.addEventListener('click', ()=>{
  // primar: si la manguera está marcada llena, la dejamos cebada; si no, intentamos cebar
  state.primed = state.hoseFilled ? true : true; // se intentará cebar en ambos casos
  state.flowing = true;
  statusEl.textContent = 'Intentando iniciar...';
});

pauseBtn.addEventListener('click', ()=>{
  state.paused = !state.paused;
  pauseBtn.textContent = state.paused? 'Reanudar' : 'Pausa';
});

resetBtn.addEventListener('click', ()=>{
  leftOffsetEl.value = 0;
  leftH.value = 40; rightH.value = 10; crestH.value = 60; diam.value = 1.5;
  hoseFilledEl.checked = false;

  state.leftOffset = 0;
  state.leftLevel = 40; state.rightLevel = 10; state.crestLevel = 60; state.diameter = 1.5;
  state.primed = false; state.flowing = false; state.paused = false; state.hoseFilled = false;

  leftOffsetTxt.textContent = state.leftOffset;
  leftHtxt.textContent = state.leftLevel;
  rightHtxt.textContent = state.rightLevel;
  crestTxt.textContent = state.crestLevel;
  diamTxt.textContent = state.diameter;

  statusEl.textContent = 'Inactivo'; pauseBtn.textContent = 'Pausa';
});

/* -------------------------
   Física ideal (SI internamente)
   ------------------------- */
function computeVelocityAndFlow(leftCm, rightCm, D_cm){
  // convertir a metros (referencia común)
  const hL = leftCm / 100;
  const hR = rightCm / 100;
  if(hL <= hR) return { v:0, Q:0 };

  const v = Math.sqrt(2 * g_SI * (hL - hR)); // m/s
  const A = Math.PI * ( (D_cm/100)**2 ) / 4; // m^2
  const Q = A * v; // m^3/s
  return { v, Q };
}

// presión en punto de altura h_x (m) usando Bernoulli simplificada entre superficie de salida y punto
function pressureAtHeight(h_x_m, h_salida_m){
  return P_ATM + rho * g_SI * (h_salida_m - h_x_m);
}

function checkCavitation(crestCm, h_salidaCm){
  const hC = crestCm / 100;
  const hS = h_salidaCm / 100;
  const pTop = pressureAtHeight(hC, hS);
  const cav = pTop <= P_VAPOR_20C;
  return { pTop, cav };
}

/* -------------------------
   Partículas
   ------------------------- */
let particles = [];
function spawnParticle(){
  const startX = tankXLeft + tankWidth - 8;
  const startY = waterYInTank(Math.max(state.leftLevel,1), state.leftOffset) + 6; // dentro del tanque
  particles.push({ t:0, x: startX, y: startY });
  if(particles.length > 220) particles.shift();
}

/* -------------------------
   Actualización (física y animación)
   ------------------------- */
function update(dt){
  if(state.paused) return;

  // Verificar cebado: la cresta debe estar por debajo del nivel izquierdo para mantener cebado,
  // a menos que el usuario haya marcado la manguera como llena (hoseFilled).
  if(state.flowing && state.primed){
    if(state.crestLevel >= state.leftLevel && !state.hoseFilled){
      state.flowing = false; state.primed = false;
      statusEl.textContent = 'No puede cebarse (cresta >= nivel izq)';
    }
  }

  if(state.flowing && state.primed){
    const { v, Q } = computeVelocityAndFlow(state.leftLevel, state.rightLevel, state.diameter);

    // comprobar cavitación en la cresta
    const cavRes = checkCavitation(state.crestLevel, state.rightLevel);
    if(cavRes.cav){
      state.flowing = false;
      state.primed = false;
      statusEl.textContent = 'Fallo por cavitación (presión en cresta ≤ presión de vapor)';
    } else {
      // actualizar niveles usando volumen (modelo simple)
      const tankAreaCm2 = 2000;
      const Q_cm3s = Q * 1e6;
      const dh_cm = (Q_cm3s / tankAreaCm2) * dt; // cm
      state.leftLevel = Math.max(0, state.leftLevel - dh_cm);
      state.rightLevel += dh_cm;

      if(Math.random() < Math.min(1, Q_cm3s / 8000)) spawnParticle();

      statusEl.textContent = 'Sifón fluyendo';
    }
  }

  // actualizar partículas
  for(const p of particles){
    p.t += dt * 0.7;
    const t = Math.min(1, p.t);

    const x0 = tankXLeft + tankWidth;
    const x3 = tankXRight;

    const y0 = waterYInTank(state.leftLevel, state.leftOffset) + 6;  // inicio dentro del tanque (ajustado)
    const y3 = waterYInTank(state.rightLevel, 0) + 6;
    const cx = (x0 + x3)/2;
    const cy = waterYInTank(state.crestLevel, state.leftOffset) + 6;

    p.drawx = (1-t)*(1-t)*x0 + 2*(1-t)*t*cx + t*t*x3;
    p.drawy = (1-t)*(1-t)*y0 + 2*(1-t)*t*cy + t*t*y3;
  }

  particles = particles.filter(p => p.t < 1.4);
}

/* -------------------------
   Dibujado (manteniendo estética)
   ------------------------- */
function drawTank(x, level, label, offset){
  const topTank = tankTopY(offset);
  const waterY = waterYInTank(level, offset);
  const waterHeight = Math.min(physToPx(level), tankHeightPx);

  ctx.save();
  ctx.translate(x,0);

  // tanque (fondo)
  ctx.fillStyle = 'rgba(0,0,0,0.04)';
  ctx.fillRect(0, topTank, tankWidth, tankHeightPx);
  ctx.strokeStyle = 'rgba(0,0,0,0.08)';
  ctx.lineWidth = 2;
  ctx.strokeRect(0, topTank, tankWidth, tankHeightPx);

  // agua -> dibujamos **solo** dentro del tanque (waterHeight)
  ctx.beginPath();
  ctx.rect(0, waterY, tankWidth, waterHeight);
  ctx.fillStyle = '#009e7d';
  ctx.fill();

  // etiquetas
  ctx.fillStyle = '#006b59';
  ctx.font = '14px Inter, Arial';
  ctx.fillText(label, 6, topTank - 12);
  ctx.font = '16px Inter, Arial';
  ctx.fillText(level.toFixed(1) + ' cm', 6, tankBottom + 18);

  ctx.restore();
}

function drawPipe(){
  const x0 = tankXLeft + tankWidth;
  const x3 = tankXRight;

  const y0 = waterYInTank(state.leftLevel, state.leftOffset) + 6; // punto de salida del agua en tanque izq
  const y3 = waterYInTank(state.rightLevel, 0) + 6;

  const cx = (x0 + x3)/2;
  const cy = waterYInTank(state.crestLevel, state.leftOffset) + 6;

  // cuerpo de la manguera (grosor dependiendo del diámetro)
  ctx.lineWidth = Math.max(14, state.diameter * 4);
  ctx.lineCap = 'round';
  ctx.strokeStyle = '#006b59';
  ctx.beginPath();
  ctx.moveTo(x0, y0);
  ctx.quadraticCurveTo(cx, cy, x3, y3);
  ctx.stroke();

  // si hay flujo, dibujar trazo discontinuo interior (agua moviéndose)
  if(state.flowing){
    ctx.lineWidth = Math.max(6, state.diameter * 3);
    ctx.setLineDash([16,10]);
    ctx.strokeStyle = '#00b48a';
    ctx.lineDashOffset = -performance.now()/40;
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.quadraticCurveTo(cx,cy,x3,y3);
    ctx.stroke();
    ctx.setLineDash([]);
  } else if(state.primed || state.hoseFilled){
    // manguera cebada: línea continua azul tenue
    ctx.lineWidth = Math.max(6, state.diameter * 3);
    ctx.strokeStyle = 'rgba(0,120,255,0.35)';
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.quadraticCurveTo(cx,cy,x3,y3);
    ctx.stroke();
  }
}

function drawParticles(){
  for(const p of particles){
    ctx.beginPath();
    ctx.arc(p.drawx, p.drawy, 3, 0, Math.PI*2);
    ctx.fillStyle = '#00b48a';
    ctx.fill();
  }
}

function drawHUD(){
  const { v, Q } = computeVelocityAndFlow(state.leftLevel, state.rightLevel, state.diameter);
  const Q_Ls = Q * 1000;        // m^3/s -> L/s
  const Q_cm3s = Q * 1e6;      // m^3/s -> cm^3/s

  const cavRes = checkCavitation(state.crestLevel, state.rightLevel);
  const p_kPa = (cavRes.pTop / 1000);

  ctx.fillStyle = '#006b59';
  ctx.font = '14px Inter, Arial';
  ctx.fillText('Velocidad: ' + v.toFixed(2) + ' m/s', 16, 28);
  ctx.fillText('Caudal: ' + Q_Ls.toFixed(3) + ' L/s (' + Math.round(Q_cm3s) + ' cm³/s)', 16, 48);
  ctx.fillText('P crest: ' + p_kPa.toFixed(2) + ' kPa', 16, 68);

  if(cavRes.cav){
    ctx.fillStyle = '#a60000';
    ctx.font = '14px Inter, Arial';
    ctx.fillText('¡CAVITACIÓN detectada — sifón falla!', 16, 92);
  }

  ctx.fillStyle = '#006b59';
  ctx.font = '13px Inter, Arial';
  ctx.fillText('Primado: ' + (state.primed? 'sí' : 'no') + '   Fluyendo: ' + (state.flowing? 'sí':'no'), 16, H-28);
}

function draw(){
  ctx.clearRect(0,0,W,H);

  drawTank(tankXLeft, state.leftLevel, 'Vaso izquierdo', state.leftOffset);
  drawTank(tankXRight, state.rightLevel, 'Vaso derecho', 0);

  drawPipe();
  drawParticles();
  drawHUD();
}

/* -------------------------
   Loop
   ------------------------- */
let last = performance.now();
function loop(t){
  const dt = (t - last)/1000;
  last = t;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* -------------------------
   Inicialización visual (ajusta textos)
   ------------------------- */
leftOffsetTxt.textContent = state.leftOffset;
leftHtxt.textContent = state.leftLevel;
rightHtxt.textContent = state.rightLevel;
crestTxt.textContent = state.crestLevel;
diamTxt.textContent = state.diameter;
hoseFilledEl.checked = state.hoseFilled;

</script>
</body>
</html>
